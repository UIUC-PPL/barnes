mainmodule barnes {
  
  /*
    Proxies for tree pieces, data managers and main chare.
  */
  readonly CProxy_TreePiece treePieceProxy;
  readonly CProxy_DataManager dataManagerProxy;
  readonly CProxy_Main mainProxy;
  readonly Parameters globalParams;

  initproc void registerReducers();

  class Parameters;
  class MultipoleMoments;

  /*
    To communicate range of particles owned by each TreePiece
  */
  message RangeMsg {
    Key keys[];
  };

  // To respond to remote request for particles 
  message ParticleReplyMsg {
    ExternalParticle data[];
  };

  // To respond to remote request for subtree under node
  message NodeReplyMsg {
    Node<ForceData> data[];
  };

  // To continuously reschedule local and remote work
  message RescheduleMsg;

  include "Descriptor.h";

  // Main chare initiates computation and ends it
  mainchare Main {
    entry Main(CkArgMsg *m);
    entry [threaded] void commence();
    entry void niceExit();
    entry void quiescence();
    entry void quiescenceExit();
  };

  include "Particle.h";

  /* 
    Particles are decomposed onto TreePieces. Each
    TreePiece traverses the global tree (possibly creating
    communication requests) to compute the forces on its
    particles.
  */

  array[1D] TreePiece {
    entry TreePiece();
    entry [reductiontarget] void receiveParticles(Particle particles[numParticles], int numParticles);
    entry void requestMoments(Key k, int replyTo);

    entry [expedited] void startTraversal();
    //entry void doLocalGravity();
    //entry void doRemoteGravity();
    entry void doLocalGravity(RescheduleMsg *);
    entry void doRemoteGravity(RescheduleMsg *);

    entry [expedited] void requestParticles(std::pair<Key, int> request);
    entry [expedited] void requestNode(std::pair<Key, int> request);
    entry void quiescence();
    entry void doAtSync();
  };

  include "Node.h";

  /*
    There is one DataManager per PE. It has several functions: 
    1. load a subset of the particles from an input file
    2. Oct-decompose particles onto TreePieces using a histogram-sort like algorithm
    3. Construct a PE-level tree from all the particles on the PE after decomposition
    4. Initiate traversals for all TreePieces on the PE after tree building
    5. Maintain a per-PE cache of data fetched from remote sources for TreePieces on the PE
    6. Update particle positions and velocities once traversals have completed.
  */
  array[1D] DataManager {
    entry DataManager();
    entry void loadParticles(CkCallback &cb);
    entry void decompose(BoundingBox &universe);
    entry void receiveHistogram(CkReductionMsg *msg);
    entry void receiveSplitters(CkVec<int> splitBins);
    entry void sendParticles(RangeMsg *msg);
    entry [expedited] void receiveMoments(MomentsExchangeStruct moments);

    entry void recvParticles(ParticleReplyMsg *msg);
    entry void recvNode(NodeReplyMsg *msg);
    entry void advance(CkReductionMsg *msg);
    entry void traversalsDone(CmiUInt8 pnInter, CmiUInt8 ppInter, CmiUInt8 openCrit);

    entry void recvUnivBoundingBox(CkReductionMsg *msg);

    entry void quiescence();
    entry void resumeFromLB();
  };
};
